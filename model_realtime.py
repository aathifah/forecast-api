# -*- coding: utf-8 -*-
"""model_realtime

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1tAp-SPkAysGIPrNBF9tSkagmRtBrdqYl
"""

def run_real_time_forecast(
    forecast_file='uploads/testing_forecast.xlsx'
):
    # Load data
    df_all = pd.read_excel(forecast_file, sheet_name='dataset')
    df_all['MONTH'] = pd.to_datetime(df_all['MONTH'], format='%Y%m')

    df_best = pd.read_excel(forecast_file, sheet_name='testing_forecast')
    df_best['MONTH'] = pd.to_datetime(df_best['MONTH'])
    df_best['FORECAST'] = pd.to_numeric(df_best['FORECAST'], errors='coerce')
    df_best['ACTUAL'] = pd.to_numeric(df_best['ACTUAL'], errors='coerce')

    def hybrid_error(row):
        f, a = row['FORECAST'], row['ACTUAL']
        if pd.isna(f) or pd.isna(a):
            return np.nan
        if a == 0 and f == 0:
            return 0
        elif a == 0:
            return 2 * abs(f - a) / (abs(f) + abs(a)) * 100
        else:
            return abs(f - a) / a * 100

    df_best['HYBRID_ERROR'] = df_best.apply(hybrid_error, axis=1)

    # Get best models from last 4 months
    latest_months = sorted(df_best['MONTH'].unique())[-4:]
    df_testing = df_best[df_best['MONTH'].isin(latest_months)].dropna(subset=['HYBRID_ERROR'])
    idx_min_error = df_testing.groupby('PART_NO')['HYBRID_ERROR'].idxmin()
    model_best_rows = df_testing.loc[idx_min_error, ['PART_NO', 'BEST_MODEL', 'HYBRID_ERROR']]
    latest_model_map = model_best_rows.set_index('PART_NO')[['BEST_MODEL', 'HYBRID_ERROR']].to_dict(orient='index')

    # Prepare forecast period (next 4 months)
    max_month = df_all['MONTH'].max()
    forecast_months = pd.date_range(start=max_month + pd.offsets.MonthBegin(), periods=4, freq='MS')
    part_list = df_all['PART_NO'].unique()

    # Ambil 6 bulan terakhir untuk setiap PART_NO
    last_6_months = pd.date_range(end=max_month, periods=6, freq='MS')

    # Buat pivot table untuk part-part yang punya data di 6 bulan terakhir
    recent_data = df_all[df_all['MONTH'].isin(last_6_months)]
    pivot = recent_data.pivot_table(
        index='PART_NO',
        columns='MONTH',
        values='ORIGINAL_SHIPPING_QTY',
        aggfunc='sum'
    ).fillna(0)


    # Cek part mana yang TIDAK 6 bulan berturut-turut nol
    valid_parts = pivot[(pivot != 0).any(axis=1)].index.tolist()


    results = []

    for part in part_list:
        if part not in valid_parts:
            for month in forecast_months:
                results.append({
                    'PART_NO': part,
                    'MONTH': month.strftime('%Y-%m'),
                    'BEST_MODEL': 'NoModel',
                    'FORECAST_OPTIMIST': 0,
                    'FORECAST_NEUTRAL': 0,
                    'FORECAST_PESSIMIST': 0,
                    'ERROR_BACKTEST': ''
                })
            continue

        if part not in latest_model_map:
            for month in forecast_months:
                results.append({
                    'PART_NO': part,
                    'MONTH': month.strftime('%Y-%m'),
                    'BEST_MODEL': 'NoModel',
                    'FORECAST_OPTIMIST': 0,
                    'FORECAST_NEUTRAL': 0,
                    'FORECAST_PESSIMIST': 0,
                    'ERROR_BACKTEST': ''
                })
            continue

        model_info = latest_model_map[part]
        best_model = model_info['BEST_MODEL']
        mape_val = model_info['HYBRID_ERROR']

        part_df = df_all[df_all['PART_NO'] == part].copy().sort_values('MONTH')
        hist = part_df.set_index('MONTH').resample('MS')['ORIGINAL_SHIPPING_QTY'].sum().fillna(0)
        series = hist.values
        df_series = hist.to_frame('ORIGINAL_SHIPPING_QTY').reset_index()

        if len(series) < 6:
            for month in forecast_months:
                results.append({
                    'PART_NO': part,
                    'MONTH': month.strftime('%Y-%m'),
                    'BEST_MODEL': best_model,
                    'FORECAST_OPTIMIST': 0,
                    'FORECAST_NEUTRAL': 0,
                    'FORECAST_PESSIMIST': 0,
                    'ERROR_BACKTEST': f"{round(mape_val, 2)}%"
                })
            continue

        # Prepare features for ML models if needed
        model_trained = None
        if best_model in ['LINREG', 'RF', 'XGB']:
            df_f = df_series.copy()
            df_f['MONTH_NUM'] = df_f['MONTH'].dt.month
            df_f['YEAR'] = df_f['MONTH'].dt.year
            df_f['MONTH_SIN'] = np.sin(2 * np.pi * df_f['MONTH_NUM'] / 12)
            df_f['MONTH_COS'] = np.cos(2 * np.pi * df_f['MONTH_NUM'] / 12)
            for i in range(1, 7):
                df_f[f'LAG_{i}'] = df_f['ORIGINAL_SHIPPING_QTY'].shift(i)
            df_f = df_f.dropna()
            if not df_f.empty:
                X_train = df_f[[f'LAG_{i}' for i in range(1, 7)] + ['MONTH_NUM', 'YEAR', 'MONTH_SIN', 'MONTH_COS']]
                y_train = df_f['ORIGINAL_SHIPPING_QTY']
                model_trained = (
                    LinearRegression() if best_model == 'LINREG' else
                    RandomForestRegressor(n_estimators=100, random_state=42) if best_model == 'RF' else
                    XGBRegressor(n_estimators=100, learning_rate=0.1, random_state=42)
                )
                model_trained.fit(X_train, y_train)

        for month in forecast_months:
            fc = 0
            if best_model == 'MA6':
                fc = forecast_ma6(series)
            elif best_model == 'WMA':
                fc = forecast_wma(series)
            elif best_model == 'ETS':
                fc = forecast_ets(series)
            elif best_model == 'ARIMA':
                fc = forecast_arima(series)
            elif model_trained:
                lags = {f'LAG_{i}': series[-i] if len(series) >= i else 0 for i in range(1, 7)}
                X_test = pd.DataFrame([{**lags, 'MONTH_NUM': month.month, 'YEAR': month.year,
                                      'MONTH_SIN': np.sin(2 * np.pi * month.month / 12),
                                      'MONTH_COS': np.cos(2 * np.pi * month.month / 12)}])
                y_pred = model_trained.predict(X_test)
                fc = float(y_pred[0]) if len(y_pred) > 0 else 0

            # Ensure forecast is not negative
            fc = max(0, fc) if not pd.isna(fc) else 0

            results.append({
                'PART_NO': part,
                'MONTH': month.strftime('%Y-%m'),
                'BEST_MODEL': best_model,
                'FORECAST_OPTIMIST': max(round(fc * 1.15), 0),
                'FORECAST_NEUTRAL': max(round(fc), 0),
                'FORECAST_PESSIMIST': max(round(fc * 0.8), 0),
                'ERROR_BACKTEST': f"{round(mape_val, 2)}%"
            })

    df_res = pd.DataFrame(results)
    output_file = 'uploads/Forecast_Result.xlsx'
    with pd.ExcelWriter(output_file, engine='openpyxl') as writer:
        df_res.to_excel(writer, sheet_name='Forecast', index=False)

    print(f"âœ… Forecast disimpan di: '{output_file}'")

run_real_time_forecast()